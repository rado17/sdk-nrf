#!/usr/bin/env python3
import serial
import time
import re
import argparse
from serial.tools import list_ports
import logging
import datetime


class SERIALClient:
    """Client class to communicate with DUT via Serial"""

    def __init__(self, port=None, baudrate=115200):
        self.port = port
        self.baudrate = baudrate

    @property
    def os_type(self):
        return "serial_type"

    def connect(self, timeout) -> str:
        """
        Establish connection with the device

        :return: an error message
        """
        # logging.info('SERIAL Access to %s', self.host)
        self.serial_conn = serial.Serial("/dev/ttyACM1", self.baudrate, timeout=timeout)
        return "CONNECTED"

    def close(self) -> None:
        """Close connection with the device"""
        # logging.info('Closing Serial connection')
        self.serial_conn.close()

    def execute_command(self, cmd: str, timeout=1):
        """Send command to the device"""
        # logging.info(cmd)
        if " ssid" in cmd:
            parts = cmd.split("ssid")
            ssid = parts[1].strip()
            cmd = parts[0] + f" ssid '{ssid}'"
        if " psk" in cmd:
            parts = cmd.split("psk")
            psk = parts[1].strip()
            cmd = parts[0] + f" psk '{psk}'"
        if "ping -c" in cmd:
            timeout = int(re.search("-c ([\d]+)", cmd).group(1))
        # elif 'ssid' in cmd:
        #    parts = cmd.split('ssid')
        #    ssid = parts[1].strip()
        #    cmd =parts[0]+f' ssid \'{ssid}\''

        # logging.info(cmd)
        cmd = f"{cmd}\n".encode(encoding="UTF-8")
        try:
            self.serial_conn.flush()
            self.serial_conn.flushOutput()
            self.serial_conn.flushInput()
            self.serial_conn.write(cmd)
            # time.sleep(timeout)
        except Exception:
            raise

    def read(self, size=1) -> str:
        """Read data from the device"""
        # self.serial_conn.reset_input_buffer()
        # out = bytes()
        # out = self.serial_conn.read(8000)
        # out = self.serial_conn.readall()
        # out = self.serial_conn.readall()
        # out = self.serial_conn.inWaiting()
        # return out
        out = bytes()
        try:
            while True:
                time.sleep(5)
                data = self.serial_conn.read(self.serial_conn.inWaiting())
                # read_data = self.serial_conn.read(data)
                # if not read_data:
                #    return out
                # out = out + read_data
                if not data:
                    f_debug = open("/tmp/debug_log.txt", "a")
                    f_debug.write(out.decode("utf-8"))
                    f_debug.close()
                    return out
                out += data
                time.sleep(1)
                logging.info(out.decode("utf-8"))

        except Exception:
            raise
        f_debug = open("/tmp/debug_log.txt", "a")
        f_debug.write(out.decode("utf-8"))
        f_debug.close()
        return out

    def get_mac_address(self, data):
        match = re.compile("ether ([\dA-Fa-f:]*)")
        if match.findall(ifconfig_data):
            dut_mac_addr = match.findall(data)[0]
            logging.info("dut_mac_addr : %s", dut_mac_addr)
        else:
            dut_mac_addr = "NO_MAC_ADDRESS"
        return dut_mac_addr

    def get_bssid(self, data):
        match = re.compile("bssid=([\dA-Fa-f:]*)")
        ap_mac_addr = match.findall(data)[0]
        logging.info("ap_mac_addr : %s", ap_mac_addr)
        return ap_mac_addr

    def connection_status(self, data):
        if ssid in data and "wpa_state=COMPLETED" in data:
            return True
        return False


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.DEBUG,
        filename=datetime.datetime.now().strftime("serial_agent_%H_%M_%d_%m_%Y.log"),
        format="%(asctime)-15s %(levelname)-8s %(message)s",
    )
    parser = argparse.ArgumentParser()
    parser.add_argument(dest="cmd")
    # parser.add_argument(dest='get_info')
    timeout = 2
    args = parser.parse_args()
    ser = SERIALClient()
    status = ser.connect(timeout=timeout)
    ser.execute_command(args.cmd)
    # logging.info(f"connection status :{status} ")
    # ser.execute_command('iwconfig')
    logging.info(f"####################### {args.cmd} ##########################\n")
    wait_time = 1
    if "duration" in args.cmd:
        f_wait_time = open("/tmp/wait_time", "w")
        wait_time_from_cmd = re.search("duration,([\d]+)", args.cmd).group(1)
        f_wait_time.write(wait_time_from_cmd)
        time.sleep(1)
        f_wait_time.close()
    if "traffic_agent_send" in args.cmd or "traffic_send_ping" in args.cmd:
        f_wait_time_read = open("/tmp/wait_time", "r")
        wait_time = f_wait_time_read.read().rstrip()
        f_wait_time_read.close()
    logging.info(wait_time)
    if "ping -c" in args.cmd:
        timeout = int(re.search("-c ([\d]+)", args.cmd).group(1))
    logging.info(wait_time)
    if "traffic_send_ping" not in args.cmd:
        time.sleep(int(wait_time))
    if 1:
        # try:
        data = ser.read().decode("utf-8", errors="ignore").rstrip()
        # data = data.replace(args.cmd, "")
        # data = data.replace("#", "")
        data = data.strip()
        # logging.info ("========================")
        # logging.info ("========================")
        # if "Printing PING OUTPUT" in data:
        # try:
        # if 1:
        #    m=re.search("Printing PING OUTPUT([\s\r\n.\w\W0-9A-Za-z]*)Printing PING OUTPUT DONE",data)
        # m=re.search("traffic_send_ping([\s\r\n.\w\W0-9A-Za-z]*)Printing RespBuf START",data)
        #   buff_data1 = m.group()
        # buff_data = m.group()
        #  logging.info ("$$$$$$$$$$$$$$$$$$$$$$$$")
        #  logging.info (buff_data1)
        #  logging.info ("$$$$$$$$$$$$$$$$$$$$$$$$")
        #  f_buf = open('/tmp/pingbuff.txt','w')
        #  f_buf.write(buff_data1)
        #  f_buf.close()
        # except:
        #    pass
        # else:
        #    pass
        if "Printing RespBuf START" in data:
            try:
                m = re.search(
                    "Printing RespBuf START[\r\n]*(.*)[\r\n]*Printing RespBuf DONE",
                    data,
                )
                if m is not None:
                    buff_data = m.group(1)
                    # logging.info (f"#######################IN SERIAL_AGENT##########################\n")
                    logging.info(buff_data)
                    if buff_data is not None:
                        f_buf = open("/tmp/tembbuff.txt", "w")
                        f_buf.write(buff_data)
                        f_buf.close()
                    else:
                        logging.info(f"Failed to regex parse in {data}")
                else:
                    logging.info(f"Failed to regex match the response in {data}")
            except Exception as e:
                logging.info(f"Exception is {e}")

        else:
            pass
    # except Exception:
    # logging.info ("DBG:2")
    # pass
    ser.close()
    # return data
    # time.sleep(2)
    # import re
    # l =re.search('inet addr:', data.decode('UTF-8'))
    # logging.info(l)
    # if args.get_info == 'get_mac':
    #    ser.get_mac_address(data)
    # elif args.get_info == 'get_bssid':
    #    ser.get_bssid(data)
    # elif args.get_info == 'is_sta_connected':
    #    ser.connection_status(data)
